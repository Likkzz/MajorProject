<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Workpiece Measurement & Grading</title>
    <style>
        body { font-family: sans-serif; background: #1a1a1a; color: #eee; margin: 0; display: flex; flex-direction: column; height: 100vh; }
        header { padding: 15px; background: #333; display: flex; justify-content: space-between; align-items: center; }
        
        .container { display: flex; flex: 1; overflow: hidden; position: relative; }
        .sidebar { width: 340px; min-width: 340px; background: #252525; padding: 20px; overflow-y: auto; border-right: 1px solid #444; z-index: 10; }
        .main-view { flex: 1; position: relative; background: #000; overflow: hidden; cursor: grab; width: 100%; height: 100%; }
        .main-view:active { cursor: grabbing; }

        .btn { padding: 10px 15px; border: none; cursor: pointer; font-weight: bold; border-radius: 4px; width: 100%; margin-bottom: 10px; }
        .btn-primary { background: #007bff; color: white; }
        .btn-secondary { background: #6c757d; color: white; }
        .btn-save { background: #27ae60; color: white; }
        .btn-grade { background: #f39c12; color: white; font-size: 1.1em; }

        input[type="file"], input[type="text"], input[type="number"], select { margin-bottom: 15px; width: 100%; padding: 8px; box-sizing: border-box; }

        .stat-box { background: #333; padding: 10px; border-radius: 4px; margin-bottom: 15px; }
        .stat-label { font-size: 0.85em; color: #aaa; }
        .stat-value { font-size: 1.2em; font-weight: bold; color: #fff; }
        .auto-highlight { color: #4cd137; }

        .instructions { background: #444; padding: 10px; border-radius: 4px; margin-bottom: 20px; font-size: 0.9em; line-height: 1.4; }
        
        table { width: 100%; border-collapse: collapse; margin-top: 10px; font-size: 0.85em; }
        th, td { border: 1px solid #555; padding: 5px; text-align: center; }
        th { background: #444; color: #ccc; }
        .err-high { color: #ff4757; font-weight: bold; }
        .err-low { color: #2ed573; }

        .spec-form { display: none; background: #333; padding: 10px; border-radius: 4px; margin-bottom: 15px; }
        .spec-form label { font-size: 0.8em; display: block; margin-bottom: 5px; }

        .score-box { margin-top: 15px; padding: 15px; background: #2c3e50; border-radius: 8px; text-align: center; display: none; border: 2px solid #f39c12; }
        .final-score { font-size: 2.5em; font-weight: bold; color: #f1c40f; }
        .score-breakdown { font-size: 0.9em; color: #bdc3c7; margin-top: 5px; text-align: left; }

        footer { background: #111; color: #888; text-align: center; padding: 15px; font-size: 0.85em; border-top: 1px solid #333; }
        canvas { display: block; } 
    </style>
</head>
<body>

<header>
    <h3>Workpiece Measurement Tool</h3>
</header>

<div class="container">
    <div class="sidebar">
        <h4>1. Measure Workpiece</h4>
        
        <button id="camBtn" class="btn btn-save" style="margin-bottom: 20px; font-size: 1.1em;" onclick="captureWebcam()">
            üì∑ Capture Live from Webcam
        </button>
        
        <hr style="border-color:#444; margin-bottom: 20px;">
        
        <label style="font-size:0.85em; color:#aaa;">Or Upload File:</label>
        <input type="file" id="imageInput" accept="image/*">
        <button class="btn btn-primary" onclick="uploadImage()">Process Uploaded Image</button>

        <div id="resultsArea" style="display:none;">
            <h4>Auto Results</h4>
            <div class="stat-box">
                <div class="stat-label">Total Length</div>
                <div class="stat-value" id="autoLength">-</div>
            </div>
            <div class="stat-box" style="border-left: 4px solid yellow;">
                <div class="stat-label">Thread OD</div>
                <div class="stat-value" id="autoOD">-</div>
            </div>
            <div class="stat-box" style="border-left: 4px solid #e056fd;">
                <div class="stat-label">Thread Core</div>
                <div class="stat-value" id="autoCore">-</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Thread Pitch</div>
                <div class="stat-value auto-highlight" id="autoPitch">-</div>
            </div>
            
            <div class="stat-box" id="collarBox" style="display:none; border-left: 4px solid #ff9f43;">
                <div class="stat-label">Convex Collar OD</div>
                <div class="stat-value" id="autoCollar">-</div>
            </div>
            <div class="stat-box" id="baseDiaBox" style="display:none; border-left: 4px solid #2ecc71;">
                <div class="stat-label">Base Dia (Smooth)</div>
                <div class="stat-value" id="autoBaseDia">-</div>
            </div>

            <hr style="border-color:#444; margin: 20px 0;">
            <h4>2. Compare & Grade</h4>
            
            <label style="font-size:0.85em; color:#aaa;">Load Model Spec:</label>
            <select id="specSelect" onchange="loadSavedSpec()">
                <option value="">-- Select Model --</option>
            </select>
            
            <button class="btn btn-secondary" style="margin-top:5px; font-size:0.8em;" onclick="toggleSpecForm()">+ Add New Model</button>

            <div id="specForm" class="spec-form">
                <h4>Add Specification</h4>
                <label>Model Name:</label>
                <input type="text" id="newSpecName" placeholder="e.g. Model A">
                <label>Length (mm):</label>
                <input type="number" id="newLen" step="0.01">
                <label>Thread OD (mm):</label>
                <input type="number" id="newOuter" step="0.01">
                <label>Thread Core (mm):</label>
                <input type="number" id="newCore" step="0.01">
                <label>Pitch (mm):</label>
                <input type="number" id="newPitch" step="0.01">
                <hr style="border-color:#555;">
                <label>Collar OD (Optional):</label>
                <input type="number" id="newCollar" step="0.01">
                <label>Base Dia (Optional):</label>
                <input type="number" id="newBaseDia" step="0.01">
                <button class="btn btn-save" onclick="saveManualSpec()">Save Model</button>
            </div>

            <div id="comparisonArea" style="display:none;">
                <h4>Specification Report</h4>
                <table>
                    <thead>
                        <tr>
                            <th>Param</th>
                            <th>Measured</th>
                            <th>Spec</th>
                            <th>Err(%)</th>
                        </tr>
                    </thead>
                    <tbody id="compTableBody"></tbody>
                </table>
                
                <button class="btn btn-grade" style="margin-top: 15px;" onclick="calculateGrade()">Calculate Grade</button>
                
                <div id="scoreResult" class="score-box">
                    <div>Final Score</div>
                    <div class="final-score" id="finalScoreVal">0/10</div>
                    <div class="score-breakdown" id="scoreDetails"></div>
                </div>
            </div>
            
            <hr style="border-color:#444; margin: 20px 0;">
            <h4>3. Visual Verification</h4>
             <div class="instructions" id="instructionText">
                <span style="color:#ff3b30">‚óè Red</span> Peaks | <span style="color:#00d2d3">‚óè Cyan</span> Valleys<br>
                <span style="color:yellow">--</span> Thrd OD | <span style="color:#e056fd">--</span> Thrd Core<br>
                <span style="color:#ff9f43">--</span> Collar OD | <span style="color:#2ecc71">--</span> Base Dia
            </div>
             <button class="btn btn-secondary" onclick="fitImage()">Fit Image</button>
        </div>

        <hr style="border-color:#444; margin: 20px 0;">
        <h4>‚öôÔ∏è Recalibrate Scale</h4>
        <div class="instructions" style="background:#3a2a00; border-left: 3px solid #f39c12;">
            Upload a <b>reference workpiece</b> with known dimensions to update the pixel-to-mm scale.
        </div>

        <label style="font-size:0.85em; color:#aaa;">Reference Image:</label>
        <input type="file" id="calImageInput" accept="image/*" style="margin-bottom:10px;">

        <label style="font-size:0.85em; color:#aaa;">Known Length (mm):</label>
        <input type="number" id="calLength" step="0.01" placeholder="e.g. 122.00" style="margin-bottom:10px;">

        <label style="font-size:0.85em; color:#aaa;">Known Outer Diameter (mm):</label>
        <input type="number" id="calOD" step="0.01" placeholder="e.g. 20.12" style="margin-bottom:10px;">

        <button class="btn" style="background:#e67e22; color:white;" onclick="runRecalibration()">
            üîÑ Run Recalibration
        </button>

        <div id="calResult" style="display:none; margin-top:10px; background:#1e3a1e; padding:10px; border-radius:4px; font-size:0.85em;">
            <div style="color:#2ed573; font-weight:bold;">‚úÖ Calibration Updated</div>
            <div id="calDetails" style="color:#aaa; margin-top:5px;"></div>
        </div>
        <div id="calError" style="display:none; margin-top:10px; background:#3a1e1e; padding:10px; border-radius:4px; color:#ff4757; font-size:0.85em;"></div>
    </div>

    <div class="main-view" id="canvasContainer">
        <canvas id="imgCanvas"></canvas>
    </div>
</div>

<footer>
    Developed by Major project team guided by Dr. Mervin Herbert, Batch of 2026.
</footer>

<script>
    let canvas = document.getElementById('imgCanvas');
    let ctx = canvas.getContext('2d');
    let container = document.getElementById('canvasContainer');
    
    let img = new Image();
    let autoPoints = { peaks: [], valleys: [], valleys_used: [], line_peaks: [], line_valleys: [], vis_outer_dia: [], vis_core_dia: [], vis_extra_lines: [] };
    let visBoundingBox = []; 
    let detectedContour = []; 
    
    let measuredData = { length: 0, outer: 0, core: 0, pitch: 0, depth: 0, collar_od: null, base_dia: null };
    let currentSpecs = null; 
    
    let scale = 1; let pX = 0; let pY = 0; let isDragging = false; let startX, startY;

    window.onload = async function() { resizeCanvas(); await loadSpecList(); };

    async function loadSpecList() {
        try {
            let resp = await fetch('/get_specs');
            let names = await resp.json();
            let sel = document.getElementById('specSelect');
            sel.innerHTML = '<option value="">-- Select Model --</option>';
            names.forEach(name => {
                let opt = document.createElement('option'); opt.value = name; opt.innerText = name; sel.appendChild(opt);
            });
        } catch(e) { console.log("Could not load specs", e); }
    }

    function resizeCanvas() {
        if (container.clientWidth > 0 && container.clientHeight > 0) {
            canvas.width = container.clientWidth; canvas.height = container.clientHeight; draw();
        }
    }
    window.addEventListener('resize', resizeCanvas);

    async function runRecalibration() {
        let fileInput = document.getElementById('calImageInput');
        let knownLength = document.getElementById('calLength').value;
        let knownOD = document.getElementById('calOD').value;

        document.getElementById('calResult').style.display = 'none';
        document.getElementById('calError').style.display = 'none';

        if (!fileInput.files.length) return alert("Select a reference image first.");
        if (!knownLength || !knownOD) return alert("Enter valid known dimensions.");

        let formData = new FormData();
        formData.append('file', fileInput.files[0]);
        formData.append('known_length', knownLength);
        formData.append('known_diameter', knownOD);

        try {
            let resp = await fetch('/recalibrate', { method: 'POST', body: formData });
            let data = await resp.json();

            if (data.error) {
                document.getElementById('calError').style.display = 'block';
                document.getElementById('calError').innerText = '‚ùå ' + data.error;
            } else {
                document.getElementById('calResult').style.display = 'block';
                document.getElementById('calDetails').innerHTML =
                    `Scale (Axis): <b>${data.new_scale_axis}</b> mm/px<br>` +
                    `Scale (Perp): <b>${data.new_scale_perp}</b> mm/px<br>`;
            }
        } catch(e) {
            document.getElementById('calError').style.display = 'block';
            document.getElementById('calError').innerText = '‚ùå Request failed: ' + e.message;
        }
    }

    function fitImage() {
        if (!img.src || img.width === 0) return;
        resizeCanvas();
        let scaleX = canvas.width / img.width;
        let scaleY = canvas.height / img.height;
        scale = Math.min(scaleX, scaleY) * 0.9;
        pX = (canvas.width - img.width * scale) / 2;
        pY = (canvas.height - img.height * scale) / 2;
        draw();
    }

    async function uploadImage() {
        let input = document.getElementById('imageInput');
        if(input.files.length === 0) return alert("Select a file first");

        let formData = new FormData();
        formData.append('file', input.files[0]);
        
        let resp = await fetch('/upload', { method: 'POST', body: formData });
        let data = await resp.json();
        if(data.error) return alert(data.error);

        document.getElementById('resultsArea').style.display = 'block';
        
        measuredData.length = data.auto_data.length_mm;
        measuredData.outer = data.auto_data.od_mm;
        measuredData.core = data.auto_data.core_mm;
        
        document.getElementById('autoLength').innerText = measuredData.length + " mm";
        document.getElementById('autoOD').innerText = measuredData.outer + " mm";
        document.getElementById('autoCore').innerText = measuredData.core + " mm";
        
        if (data.auto_data.thread_metrics && Object.keys(data.auto_data.thread_metrics).length > 0) {
            let t = data.auto_data.thread_metrics;
            measuredData.pitch = t.pitch_mm;
            measuredData.depth = t.depth_mm;
            document.getElementById('autoPitch').innerText = `${t.pitch_mm} mm (${t.pitch_tpi} TPI)`;
        }
        
        measuredData.collar_od = null;
        measuredData.base_dia = null;
        if(data.auto_data.geometry_metrics) {
            let gm = data.auto_data.geometry_metrics;
            if(gm.collar) {
                measuredData.collar_od = gm.collar.od_mm;
                document.getElementById('collarBox').style.display = 'block';
                document.getElementById('autoCollar').innerText = `${gm.collar.od_mm} mm (Len: ${gm.collar.len_mm}mm)`;
            } else document.getElementById('collarBox').style.display = 'none';
            
            if(gm.base_dia) {
                measuredData.base_dia = gm.base_dia.dia_mm;
                document.getElementById('baseDiaBox').style.display = 'block';
                document.getElementById('autoBaseDia').innerText = `${gm.base_dia.dia_mm} mm (Len: ${gm.base_dia.len_mm}mm)`;
            } else document.getElementById('baseDiaBox').style.display = 'none';
        }

        img.onload = function() {
            autoPoints = data.auto_data.all_points || {};
            visBoundingBox = data.auto_data.vis_bounding_box || [];
            detectedContour = data.auto_data.contour || [];
            fitImage(); 
            if(document.getElementById('specSelect').value) loadSavedSpec();
        };
        img.src = data.image_url;
    }

    async function captureWebcam() {
        let btn = document.getElementById('camBtn');
        let originalText = btn.innerHTML;
        
        // Show loading state since the webcam takes a second to focus
        btn.innerHTML = "‚è≥ Taking Photo...";
        btn.disabled = true;
        btn.style.background = "#555";

        try {
            let resp = await fetch('/capture', { method: 'POST' });
            let data = await resp.json();
            
            if(data.error) {
                alert(data.error);
            } else {
                // If successful, populate the UI exactly the same way an upload does
                populateResultsUI(data); 
            }
        } catch(e) {
            alert("Network error: Could not reach webcam endpoint.");
        }

        // Restore button state
        btn.innerHTML = originalText;
        btn.disabled = false;
        btn.style.background = "#27ae60";
    }

    // Helper function to prevent repeating the UI update code
    function populateResultsUI(data) {
        document.getElementById('resultsArea').style.display = 'block';
        
        measuredData.length = data.auto_data.length_mm;
        measuredData.outer = data.auto_data.od_mm;
        measuredData.core = data.auto_data.core_mm;
        
        document.getElementById('autoLength').innerText = measuredData.length + " mm";
        document.getElementById('autoOD').innerText = measuredData.outer + " mm";
        document.getElementById('autoCore').innerText = measuredData.core + " mm";
        
        if (data.auto_data.thread_metrics && Object.keys(data.auto_data.thread_metrics).length > 0) {
            let t = data.auto_data.thread_metrics;
            measuredData.pitch = t.pitch_mm;
            measuredData.depth = t.depth_mm;
            document.getElementById('autoPitch').innerText = `${t.pitch_mm} mm (${t.pitch_tpi} TPI)`;
        }
        
        measuredData.collar_od = null;
        measuredData.base_dia = null;
        if(data.auto_data.geometry_metrics) {
            let gm = data.auto_data.geometry_metrics;
            if(gm.collar) {
                measuredData.collar_od = gm.collar.od_mm;
                document.getElementById('collarBox').style.display = 'block';
                document.getElementById('autoCollar').innerText = `${gm.collar.od_mm} mm (Len: ${gm.collar.len_mm}mm)`;
            } else document.getElementById('collarBox').style.display = 'none';
            
            if(gm.base_dia) {
                measuredData.base_dia = gm.base_dia.dia_mm;
                document.getElementById('baseDiaBox').style.display = 'block';
                document.getElementById('autoBaseDia').innerText = `${gm.base_dia.dia_mm} mm (Len: ${gm.base_dia.len_mm}mm)`;
            } else document.getElementById('baseDiaBox').style.display = 'none';
        }

        img.onload = function() {
            autoPoints = data.auto_data.all_points || {};
            visBoundingBox = data.auto_data.vis_bounding_box || [];
            detectedContour = data.auto_data.contour || [];
            fitImage(); 
            if(document.getElementById('specSelect').value) loadSavedSpec();
        };
        img.src = data.image_url;
    }
    
    function toggleSpecForm() {
        let form = document.getElementById('specForm');
        form.style.display = (form.style.display === 'none' || form.style.display === '') ? 'block' : 'none';
    }
    
    async function saveManualSpec() {
        let name = document.getElementById('newSpecName').value;
        let len = parseFloat(document.getElementById('newLen').value);
        let outer = parseFloat(document.getElementById('newOuter').value);
        let core = parseFloat(document.getElementById('newCore').value);
        let pitch = parseFloat(document.getElementById('newPitch').value);
        let collar = parseFloat(document.getElementById('newCollar').value) || null;
        let base_dia = parseFloat(document.getElementById('newBaseDia').value) || null;

        if(!name || isNaN(len) || isNaN(outer) || isNaN(core) || isNaN(pitch)) {
            return alert("Please fill standard fields correctly.");
        }

        let specs = { length_mm: len, outer_dia_mm: outer, core_dia_mm: core, pitch_mm: pitch, collar_od_mm: collar, base_dia_mm: base_dia };
        
        let resp = await fetch('/save_spec', {
            method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({name: name, specs: specs})
        });
        
        if(resp.ok) { alert("Model Saved!"); toggleSpecForm(); loadSpecList(); }
    }
    
    async function loadSavedSpec() {
        let name = document.getElementById('specSelect').value;
        if(!name) return;
        let resp = await fetch(`/get_spec/${name}`);
        if(resp.ok) { currentSpecs = await resp.json(); renderComparisonTable(currentSpecs); }
    }

    function renderComparisonTable(specs) {
        let tbody = document.getElementById('compTableBody'); tbody.innerHTML = "";
        document.getElementById('comparisonArea').style.display = 'block'; document.getElementById('scoreResult').style.display = 'none';

        function addRow(label, measured, spec) {
            if(!measured || !spec) return;
            let mVal = parseFloat(measured) || 0; let sVal = parseFloat(spec);
            let percent = (Math.abs(mVal - sVal) / sVal) * 100;
            let cls = (percent < 10.0) ? "err-low" : "err-high";
            tbody.innerHTML += `<tr><td>${label}</td><td>${mVal}</td><td>${sVal}</td><td class="${cls}">${percent.toFixed(2)}%</td></tr>`;
        }

        addRow("Length", measuredData.length, specs.length_mm);
        addRow("Thrd OD", measuredData.outer, specs.outer_dia_mm);
        addRow("Thrd Core", measuredData.core, specs.core_dia_mm);
        addRow("Pitch", measuredData.pitch, specs.pitch_mm);
        if(specs.collar_od_mm) addRow("Collar OD", measuredData.collar_od, specs.collar_od_mm);
        if(specs.base_dia_mm) addRow("Base Dia", measuredData.base_dia, specs.base_dia_mm);
    }
    
    function calculateGrade() {
        if (!currentSpecs) return alert("Load a model spec first.");
        
        let score = 0; let maxTotal = 0; let log = "";
        
        function gradeParam(label, measured, spec, maxMarks) {
            if(!measured || !spec) return 0;
            maxTotal += maxMarks;
            let m = parseFloat(measured); let s = parseFloat(spec);
            let errPercent = (Math.abs(m - s) / s) * 100;
            let earned = (errPercent <= 10.0) ? maxMarks : (errPercent <= 20.0) ? maxMarks * 0.75 : maxMarks * 0.50;
            log += `<div><b>${label}:</b> ${earned}/${maxMarks} (Err: ${errPercent.toFixed(1)}%)</div>`;
            return earned;
        }
        
        score += gradeParam("Length", measuredData.length, currentSpecs.length_mm, 4);
        score += gradeParam("Thrd OD", measuredData.outer, currentSpecs.outer_dia_mm, 3);
        score += gradeParam("Thrd Core", measuredData.core, currentSpecs.core_dia_mm, 1);
        score += gradeParam("Pitch", measuredData.pitch, currentSpecs.pitch_mm, 1);
        if(currentSpecs.collar_od_mm) score += gradeParam("Collar OD", measuredData.collar_od, currentSpecs.collar_od_mm, 2);
        if(currentSpecs.base_dia_mm) score += gradeParam("Base Dia", measuredData.base_dia, currentSpecs.base_dia_mm, 2);
        
        document.getElementById('scoreResult').style.display = 'block';
        document.getElementById('finalScoreVal').innerText = score.toFixed(1) + "/" + maxTotal;
        document.getElementById('scoreDetails').innerHTML = log;
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save(); ctx.translate(pX, pY); ctx.scale(scale, scale);
        if(img.src) ctx.drawImage(img, 0, 0);

        let markerSize = 6 / scale;
        
        if(detectedContour.length > 0) {
            ctx.beginPath(); ctx.moveTo(detectedContour[0][0], detectedContour[0][1]);
            for(let i=1; i<detectedContour.length; i++) ctx.lineTo(detectedContour[i][0], detectedContour[i][1]);
            ctx.closePath(); ctx.lineWidth = 2 / scale; ctx.strokeStyle = '#4cd137'; ctx.stroke();
        }

        if(autoPoints.peaks) {
            ctx.fillStyle = '#ff3b30'; 
            autoPoints.peaks.forEach(p => { ctx.beginPath(); ctx.arc(p.x, p.y, markerSize, 0, 2 * Math.PI); ctx.fill(); });
        }

        if(autoPoints.valleys) {
            autoPoints.valleys.forEach(p => {
                ctx.beginPath(); ctx.arc(p.x, p.y, markerSize, 0, 2 * Math.PI);
                ctx.fillStyle = (p.is_used) ? '#00d2d3' : '#7f8c8d'; ctx.fill();
            });
        }

        // Dotted lines connecting Peaks and Valleys
        if(autoPoints.line_peaks && autoPoints.line_peaks.length === 2) {
            drawLine(autoPoints.line_peaks, 'yellow', 2 / scale, [5/scale, 5/scale]);
        }
        if(autoPoints.line_valleys && autoPoints.line_valleys.length === 2) {
            drawLine(autoPoints.line_valleys, '#00d2d3', 2 / scale, [5/scale, 5/scale]);
        }

        if (visBoundingBox.length === 4) {
            ctx.beginPath(); ctx.moveTo(visBoundingBox[0][0], visBoundingBox[0][1]);
            for (let i = 1; i < 4; i++) ctx.lineTo(visBoundingBox[i][0], visBoundingBox[i][1]);
            ctx.closePath(); ctx.lineWidth = 2 / scale; ctx.setLineDash([15 / scale, 15 / scale]); 
            ctx.strokeStyle = '#00a8ff'; ctx.stroke(); ctx.setLineDash([]); 
        }
        
        if (autoPoints.vis_outer_dia && autoPoints.vis_outer_dia.length === 2) drawLine(autoPoints.vis_outer_dia, 'yellow', 3 / scale, []);
        if (autoPoints.vis_core_dia && autoPoints.vis_core_dia.length === 2) drawLine(autoPoints.vis_core_dia, '#e056fd', 3 / scale, []);
        
        // DRAW DYNAMIC EXTRA LINES (Collars / Base Dia)
        ctx.font = `bold ${14 / scale}px sans-serif`;
        ctx.shadowColor = "black"; ctx.shadowBlur = 4 / scale; ctx.shadowOffsetX = 2 / scale; ctx.shadowOffsetY = 2 / scale;

        if (autoPoints.vis_extra_lines) {
            autoPoints.vis_extra_lines.forEach(line => {
                drawLine(line.points, line.color, 3 / scale, []);
                ctx.fillStyle = line.color;
                let textX = line.points[0][0]; let textY = line.points[0][1] - (8 / scale);
                ctx.fillText(`${line.label}: ${line.val} mm`, textX, textY);
            });
        }

        // Standard labels
        if (autoPoints.vis_outer_dia && autoPoints.vis_outer_dia.length === 2) {
            ctx.fillStyle = "yellow"; ctx.fillText(`Thrd OD: ${measuredData.outer} mm`, autoPoints.vis_outer_dia[0][0], autoPoints.vis_outer_dia[0][1] - (8 / scale));
        }
        if (autoPoints.vis_core_dia && autoPoints.vis_core_dia.length === 2) {
            ctx.fillStyle = "#e056fd"; ctx.fillText(`Thrd Core: ${measuredData.core} mm`, autoPoints.vis_core_dia[0][0], autoPoints.vis_core_dia[0][1] - (8 / scale));
        }
        if (visBoundingBox.length > 0 && measuredData.pitch > 0) {
            ctx.fillStyle = "#4cd137";
            ctx.fillText(`Pitch: ${measuredData.pitch} mm`, visBoundingBox[0][0], visBoundingBox[0][1] - (15 / scale));
            ctx.fillText(`Length: ${measuredData.length} mm`, visBoundingBox[0][0], visBoundingBox[0][1] - (30 / scale));
        }

        ctx.shadowColor = "transparent";
        ctx.restore();
    }

    function drawLine(points, color, width, dash = []) {
        ctx.beginPath(); ctx.moveTo(points[0][0], points[0][1]); ctx.lineTo(points[1][0], points[1][1]);
        ctx.lineWidth = width; ctx.strokeStyle = color; ctx.setLineDash(dash); ctx.stroke(); ctx.setLineDash([]); 
    }

    container.addEventListener('mousedown', (e) => { isDragging = true; startX = e.clientX - pX; startY = e.clientY - pY; });
    window.addEventListener('mousemove', (e) => { if(isDragging) { pX = e.clientX - startX; pY = e.clientY - startY; draw(); } });
    window.addEventListener('mouseup', () => { isDragging = false; });
    container.addEventListener('wheel', (e) => {
        e.preventDefault();
        let zoom = Math.exp((e.deltaY < 0 ? 1 : -1) * 0.1);
        let rect = canvas.getBoundingClientRect();
        pX = (e.clientX - rect.left) - ((e.clientX - rect.left) - pX) * zoom;
        pY = (e.clientY - rect.top) - ((e.clientY - rect.top) - pY) * zoom;
        scale *= zoom; draw();
    });
</script>
</body>
</html>